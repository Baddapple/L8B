<?xml version="1.0" encoding="UTF-8"?>
<scene id="id624038" GSCVersion="1.24.35" PGFVersion="0.24"><layers><layer id="id328997"><actors/><attributes><text id="name">Camera</text><boolean id="scrollable">true</boolean></attributes></layer><layer id="id948735"><actors><actor id="id277877" prototype="id666638"><attributes><point id="position"><real id="x">384</real><real id="y">512</real></point><size id="size"><real id="width">800</real><real id="height">1100</real></size><color id="color"><real id="red">1</real><real id="green">1</real><real id="blue">1</real><real id="alpha">1</real></color><image id="image">bg_asteroids</image></attributes><aspects><physics><attributes><boolean id="movable">true</boolean></attributes></physics></aspects><behaviors><behavior id="id717571" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">CamSize</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">self.attributes.size.height</text><text id="RHS"><expression><reference keypath="game.attributes.id623313"/><string xml:space="preserve">*2</string></expression></text></attributes></behavior></behaviors></actor></actors><attributes><text id="name">Dragger</text><boolean id="scrollable">false</boolean></attributes></layer><layer id="id172343"><actors><actor id="id544976" prototype="id699823"><attributes><text id="name">CoinDoubler Button</text><point id="position"><real id="x">384</real><real id="y">700</real></point><size id="size"><real id="width">512</real><real id="height">150</real></size><image id="image">Credit--Doubler</image></attributes><aspects/><behaviors><behavior id="id980331" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Cam Y Offset</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">self.attributes.position.y</text><text id="RHS"><expression><reference keypath="self.attributes.position.y"/><string xml:space="preserve">+</string><reference keypath="game.attributes.id628667"/></expression></text></attributes></behavior><behavior id="id419868" class="CompoundBehavior" enabled="true"><attributes><text id="name">New Code for Purchase</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id244292" class="CompoundBehavior" enabled="true"><attributes><text id="name">Load state of Ads Disabled attribute</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id518352" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First we need to load the saved state of the attribute we are going to use to save the state of the IAP. We need a game attribute (or table, if there are multiple IAPs) to save the state so we don’t need to depend on an internet connection to fill the PurchaseTable. If we don’t use a game attribute and the user doesn’t have an internet connection, there is no way to know if they have purchased the IAP or not. We store this using the “game.Item Purchased” attribute. 🔚</text></attributes></behavior><behavior id="id549614" class="LoadAttributeAction" enabled="true"><attributes><text id="name">Load state of CoinDoubler Purchased</text><text id="bundleName">LoadAtribute.behavior</text><text id="targetAttribute">game.attributes.id148026</text><text id="key">item1</text></attributes></behavior></behaviors></behavior><behavior id="id621415" class="CompoundBehavior" enabled="true"><attributes><text id="name">When the user presses the Buy Now button</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id320980" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When the user presses the Buy Now button, we have to check a number of attributes to see if the button is currently pressable. We first check if the IAP has already been bought, by ensuring the “game.Item Purchased” attribute is false. If it’s true, this button is disabled and we can reject any press. We also need to check if either a buy or restore is already in progress, and we do this by ensuring the “game.Buying” and “game.Restoring” attributes are false. 🔚</text></attributes></behavior><behavior enabled="true" id="id348092" class="RuleBehavior"><attributes><text id="name">Touch is pressed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id693781" pluginPredicateTypeIndex="0" eventType="touch"><attributes><index id="conditionType">0</index></attributes><predicate type="touch" conditionType="pressed"><attributes/></predicate></condition><condition id="id342190" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id788841" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id759606" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition></conditions><behaviors><behavior id="id551000" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the user has pressed the button, we need to provide some feedback. We do this by changing the button’s image to one telling the user to wait. This reassures the user that their press of the button has had some action. If we don’t change the image, it is likely to be a few seconds before they get Apple’s login or confirm purchase popups. 🔚</text></attributes></behavior><behavior id="id524592" class="PlaySoundAction" enabled="true"><attributes><text id="name">Play Sound</text><text id="bundleName">PlaySound.behavior</text><sound id="soundName">Coin2</sound><boolean id="loop">false</boolean><boolean id="runToCompletion">true</boolean><boolean id="positional">false</boolean><boolean id="dopplerShift">false</boolean><real id="volume">1</real><real id="pitch">1</real></attributes></behavior><behavior id="id238990" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Please-Wait</image></attributes></behavior><behavior id="id184789" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">The restore button also needs to know that the user pressed the Buy button. You could possibly rely on the 5th column of the PurchaseTable to notify the Restore button - this will soon be changed from “unpurchased” to “pending”. However, using that method relies on the table being filled with a Request Purchase Data behaviour, and we’re wanting to avoid triggering that until the user presses a button, so we need to rely on a game (or scene) attribute instead. We set that to true here.

Additionally, since we’re not calling the Request Purchase Data behaviour until the button is pressed, we need an attribute to trigger the actual purchase once the table is filled. 🔚</text></attributes></behavior><behavior id="id302384" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">true</text></attributes></behavior><behavior id="id597511" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Now we need to actually call the Request Purchase Data behaviour, and fill the PurchaseTable. First though we need to check that it hasn’t already been successfully filled. When you use a Request Purchase Data behaviour, it will fill the callback attribute you define with a 1 if it has succeeded, or a -1 if it has failed. If the callback attribute is not 1, the table has either not been attempted to be filled or has failed to fill, and we can trigger the Request Purchase Data behaviour.

The “Callback” attribute needs to be a game attribute so that the Restore button can also have access to the state of the table. Again we could use the contents of the 5th column of the PurchaseTable, but since we have to use an attribute to use the behaviour we might as well put it to full use. 🔚</text></attributes></behavior><behavior enabled="true" id="id599813" class="RuleBehavior"><attributes><text id="name">Rule</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id615225" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">!=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id758829" class="IAPRequestPurchaseDataAction" enabled="true"><attributes><text id="name">In App Purchase - Request Purchase Data</text><text id="bundleName">IAPRequestPurchaseData.behavior</text><text id="startIndex">1</text><text id="endIndex">-1</text><text id="callbackAttribute">game.attributes.id552612</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id225603" class="CompoundBehavior" enabled="true"><attributes><text id="name">Table filled - Success</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id783967" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Once the PurchaseTable has been successfully filled, GameSalad will change the “game.Callback” attribute to 1. As soon as this happens, we can get on with the actual Buying. 🔚</text></attributes></behavior><behavior enabled="true" id="id743979" class="RuleBehavior"><attributes><text id="name">Table filled - Success</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id108879" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id130495" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We only need to trigger the Buy behaviour if the player has pressed the Buy button. We are only ever going to allow a Buy to take place when the PurchaseTable has been filled, so we need to have that as a condition. We could actually combine these two rules into one rule with two conditions, but for this Tutorial Template it’s a clearer sequence of events if we separate them out.

If the PurchaseTable has been filled and the user has pressed the Buy button, triggering the “game.Buying” attribute, we make the actual purchase attempt. 🔚</text></attributes></behavior><behavior enabled="true" id="id575188" class="RuleBehavior"><attributes><text id="name">Buy the item</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id445512" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id735202" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Here we send the actual purchase request. 🔚</text></attributes></behavior><behavior id="id157932" class="IAPBuyItemAction" enabled="true"><attributes><text id="name">In App Purchase - Buy Item</text><text id="bundleName">IAPBuyItem.behavior</text><text id="itemIdentifier">credit_doubler</text></attributes></behavior><behavior id="id819230" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">This Change Table Value is not needed in any actual game is only included to make testing a little easier. In a real game, the moment the Purchase behaviour is triggered, GameSalad will change the 5th column of the PurchaseTable to “pending”. This happens automatically in a properly made ad hoc build, but doesn’t happen in Creator, Preview, or some types of ad hoc. Including this Change Table Value just saves us from having to press the “Pending” button that’s included in this Tutorial Template for illustrative and testing purposes.

Be sure to remove this (or not include it in the first place) if you use this method for IAP in your own game. 🔚</text></attributes></behavior><behavior class="ChangeTableValueAction" enabled="true"><attributes><text id="name">Change Table Value</text><text id="bundleName">ChangeTableValue.behavior</text><text id="tableID"></text><text id="tableExpression"><expression><reference keypath="game.attributes.id395449"/></expression></text><text id="rowNumber">1</text><array id="assignments"><tablecolumnassignment id="id429860"><text id="column">5</text><text id="rhsvalue">pending</text></tablecolumnassignment></array></attributes></behavior><behavior id="id209131" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When “game.Callback” is 1, and “game.Buying” is true, we can safely expect the cell in the 5th column of the PurchaseTable to say “pending”, as outlined above. This means that if both these conditions are valid and this cell says “unpurchased”, we know that purchase has failed - either because a connection could not be established, or more likely because the user pressed “Cancel”. In either case, we need to record that a purchase is no longer being attempted by setting “game.Buying” to false.

GameSalad does not guarantee order of execution of its behaviours, though. It is extremely unlikely but *possible* that this rule would be evaluated before the Purchase behaviour has been triggered and the cell changed to “pending”. You may want to put this rule in a short timer to ensure that the Purchase behaviour has time to trigger. I haven’t done so here, though. Worst case scenario is that the purchase is cancelled prematurely and the user has to trigger it again. 🔚</text></attributes></behavior><behavior enabled="true" id="id591025" class="RuleBehavior"><attributes><text id="name">Buying Failed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id754018" eventType="mouse position"><attributes><index id="conditionType">3</index></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS">unpurchased</text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><string xml:space="preserve">tableCellValue(</string><reference keypath="game.attributes.id395449"/><string xml:space="preserve">,1,5)</string></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id561446" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the purchase failed, for whatever reason, we may want to indicate this to the user by changing the Buy button’s image to reflect this failure. This is entirely optional, and if you do choose to do so you may want to revert the image back to the normal image after a set period of time, perhaps 3 seconds. We do this in a rule at the end. 🔚</text></attributes></behavior><behavior id="id143559" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Buy-Failed</image></attributes></behavior><behavior id="id837577" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">false</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id622027" class="CompoundBehavior" enabled="true"><attributes><text id="name">Table filled - Failure</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id157341" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If the PurchaseTable cannot be filled - for whatever reason - GameSalad will return a value of -1 using the “game.Callback” attribute. If this happens, we need to record that the purchase attempt has failed and keep trying to fill the PurchaseTable at set intervals. Until the table is successfully filled, both the Buy and Restore buttons will display an image that indicates this failure to connect to Apple’s servers to fill the table.

The user can either wait 10 seconds (or whatever interval you decide) for another attempt to be made, or can force another attempt by pressing either the Buy or Restore button. 🔚</text></attributes></behavior><behavior enabled="true" id="id358404" class="RuleBehavior"><attributes><text id="name">Table filled - Failure</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id536321" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">-1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id916928" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">The PurchaseTable couldn’t be filled, so there was a problem with the connection. We change the Buy button’s image to reflect this. 🔚</text></attributes></behavior><behavior id="id269110" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Can't-Connect</image></attributes></behavior><behavior id="id775072" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Without being able to talk to Apple, there’s no point trying to make a purchase, so we set “game.Buying” back to false, cancelling the purchase attempt. 🔚</text></attributes></behavior><behavior id="id733304" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">false</text></attributes></behavior><behavior id="id928110" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We might as well keep trying to fill the PurchaseTable, so every 10 seconds we’ll try again, until the table is filled. You can use any interval, but 10s seemed about right. 🔚</text></attributes></behavior><behavior id="id293551" class="TimerBehavior" enabled="true"><attributes><text id="name">Timer</text><text id="bundleName">Timer.behavior</text><index id="timerType">0</index><real id="interval">10</real><boolean id="runToCompletion">false</boolean></attributes><behaviors><behavior id="id322984" class="IAPRequestPurchaseDataAction" enabled="true"><attributes><text id="name">In App Purchase - Request Purchase Data</text><text id="bundleName">IAPRequestPurchaseData.behavior</text><text id="startIndex">1</text><text id="endIndex">-1</text><text id="callbackAttribute">game.attributes.id552612</text></attributes></behavior></behaviors></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id611988" class="CompoundBehavior" enabled="true"><attributes><text id="name">The IAP is successfully bought</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id250198" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When the 5th column of the PurchaseTable changes to “purchased”, we need to register this in several ways. It indicates a successful purchase and so we need to change and save the “game.Item Purchased” attribute, as well as note that we are no longer buying an item. Finally, we change the button image.

This rule also works to trigger the change when a Restore is successfully completed, as the same table cell will change. 🔚</text></attributes></behavior><behavior enabled="true" id="id927834" class="RuleBehavior"><attributes><text id="name">Buying Succeeded</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id754018" eventType="mouse position"><attributes><index id="conditionType">3</index></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS">purchased</text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><string xml:space="preserve">tableCellValue(</string><reference keypath="game.attributes.id395449"/><string xml:space="preserve">,1,5)</string></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id325626" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First, we change the “game.Buying” attribute. As already mentioned, we need this attribute to indicate to other actors (in this case the Restore button) that a Buy is in progress. Since the Buy is now being completed, we note this by setting the “game.Buying” attribute to false.

Some of these things will only need to be triggered if the user is Buying, rather than Restoring, so we can put them in a rule to avoid processing them if it’s a Restore that’s triggered the change to the PurchaseTable. We find this out by checking the “game.Buying” attribute. We could actually handle all of the logic for completing a Restore in this actor too, and avoid a bit of duplication, but it seemed easier to have each button do its own thing for the sake of clarity in this Tutorial Template. 🔚</text></attributes></behavior><behavior enabled="true" id="id684125" class="RuleBehavior"><attributes><text id="name">When the user is Buying, not Restoring</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id871998" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id563257" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First, we change the “game.Buying” attribute. As already mentioned, we need this attribute to indicate to other actors (in this case the Restore button) that a Buy is in progress. Since the Buy is now being completed, we note this by setting the “game.Buying” attribute to false. 🔚</text></attributes></behavior><behavior id="id503654" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS"><expression><string xml:space="preserve">true</string></expression></text></attributes></behavior><behavior id="id276824" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We’re storing the state of the purchase in the “game.Item Purchased” boolean attribute. If we don’t use this attribute, the game has no way of knowing if this item has been purchased when the user has no internet connection (and so the PurchaseTable is empty). As an alternative, we can save the PurchaseTable each time it is changed, but that seems to be a risky method that could lead to incorrect information. Using an attribute to store this information is cleaner and involves less processing. Here we set this attribute to “true” to record that the purchase has been successfully made. We then save it so its state will be remembered next time the game is launched. 🔚</text></attributes></behavior><behavior id="id117799" class="SaveAttributeAction" enabled="true"><attributes><text id="name">Save Attribute</text><text id="bundleName">SaveAttribute.behavior</text><text id="targetAttribute">game.attributes.id148026</text><text id="key"><expression><string xml:space="preserve">item1</string></expression></text></attributes></behavior><behavior id="id303045" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">true</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id193890" class="CompoundBehavior" enabled="true"><attributes><text id="name">When the IAP has been purchased and the game attribute changed</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id658795" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We need to be checking for when the IAP Item has been purchased, and that change has been saved to our “game.Item Purchased” attribute. It may be that the user just completed a purchase and this attribute was changed in the rule above, or it may be that they purchased it in a previous session and the attribute has just been loaded by the game. Either way, we need to set the image for the Buy button to “Buy-Disabled”. 🔚</text></attributes></behavior><behavior enabled="true" id="id321137" class="RuleBehavior"><attributes><text id="name">When the IAP has been purchased and the game attribute changed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id989636" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id899748" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the purchase has been completed, either in a previous session or this one, we change the Buy button’s image to show this. In this example we’re just using a greyed-out version of the Buy image, but you could just as easily use any visual indication that this item has been purchased and is no longer available to buy. 🔚</text></attributes></behavior><behavior id="id487277" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Credit--Doubler-Purchased</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id421477" class="CompoundBehavior" enabled="true"><attributes><text id="name">When Restoring Item</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id459708" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If the player presses the Restore button, we need to show that this action is in progress by changing the image of the Buy button too. We do that here. Just as we used a “game.Buying” attribute to indicate when a Buy is in progress, we use the “game.Restoring” attribute to show when a Restore is in progress. 🔚</text></attributes></behavior><behavior enabled="true" id="id425551" class="RuleBehavior"><attributes><text id="name">When Restoring Item</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id223388" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id771687" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since a Restore has been requested but not yet completed, we need to change the Buy button’s image to our “Please wait” image. As soon as the Restore is completed, we’ll either change the image back to our normal Buy button image, which happens below in the “Re-enable button when usable” rule, or replace it with the disabled image using the “The IAP is successfully bought” rule above. 🔚</text></attributes></behavior><behavior id="id880111" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Please-Wait</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id469880" class="CompoundBehavior" enabled="true"><attributes><text id="name">Re-enable button when usable</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id134816" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If we have no reason to change the Buy button’s image, we have to set it back to it’s default state. We need to check a whole bunch of things, though, to know that this should happen:

1. We have to check that we’re not currently Buying the item (if we were, “self.Image” would be set to “Buy-Wait”)
2. We have to check that we’re not currently Restoring the item (again, if we are “self.Image” would be set to “Buy-Wait”)
3. We have to check that the PurchaseTable has been successfully filled (again, “Buy-Wait” if not)
4. We have to check that the item hasn’t already been purchased (if it has been, “Buy-Disabled” will be displayed)
5. Finally, we don’t want to override the “Buy-Failed” image if that’s being displayed, so we have to check that it isn’t (if it is, we keep displaying “Buy-Failed”) - you can safely remove this condition if you aren’t using a failed image for the Buy button 🔚</text></attributes></behavior><behavior enabled="true" id="id724016" class="RuleBehavior"><attributes><text id="name">Re-enable button when usable</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id223388" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id468381" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id387005" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition><condition id="id989636" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id190670" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">self.attributes.image</text></attributes><predicate type="string"><attributes><text id="operator">isNot</text><text id="RHS">Can't-Connect</text></attributes></predicate></condition></conditions><behaviors><behavior id="id154131" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Credit--Doubler</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id388021" class="CompoundBehavior" enabled="true"><attributes><text id="name">Reset button image after a failure</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id195156" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If you are choosing to display a “Buy-Failed” image, you may wish to restore the default image after a few seconds. There’s no specific need to - it may be that you prefer to leave the failed message there until the user attempts the purchase again. But if you do want to restore the default image, we just need to use a timer that changes the image after the desired interval. The only condition we need to place on it is that the “Buy-Failed” image is currently being displayed. 🔚</text></attributes></behavior><behavior enabled="true" id="id294953" class="RuleBehavior"><attributes><text id="name">Reset button image after a failure</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id389874" eventType="mouse position"><attributes><index id="conditionType">3</index><text id="subjectAttribute">self.attributes.image</text></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS"><expression><string xml:space="preserve">Can't-Connect</string></expression></text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><reference keypath="self.attributes.image"/></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id886658" class="TimerBehavior" enabled="true"><attributes><text id="name">Timer</text><text id="bundleName">Timer.behavior</text><index id="timerType">1</index><real id="interval">3</real><boolean id="runToCompletion">false</boolean></attributes><behaviors><behavior id="id927015" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Credit--Doubler</image></attributes></behavior></behaviors></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior></behaviors></behavior></behaviors></actor><actor id="id684762" prototype="id699823"><attributes><text id="name">Rating</text><point id="position"><real id="x">384</real><real id="y">100</real></point><size id="size"><real id="width">512</real><real id="height">150</real></size><image id="image">UI_Blank_Button</image></attributes><aspects/><behaviors><behavior id="id286482" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Cam Y Offset</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">self.attributes.position.y</text><text id="RHS"><expression><reference keypath="self.attributes.position.y"/><string xml:space="preserve">+</string><reference keypath="game.attributes.id628667"/></expression></text></attributes></behavior><behavior id="id673194" class="DisplayTextBehavior" enabled="true"><attributes><text id="name">Display Text</text><text id="bundleName">DisplayText.behavior</text><text id="text">RATING</text><text id="font">American Typewriter</text><real id="size">32</real><index id="alignment">1</index><boolean id="wrap">true</boolean><color id="color"><real id="red">1</real><real id="green">1</real><real id="blue">1</real><real id="alpha">1</real></color><real id="offsetx">0</real><real id="offsety">-50</real><index id="space">0</index><index id="directionSpace">0</index><angle id="direction">0</angle></attributes></behavior><behavior enabled="true" id="id325817" class="RuleBehavior"><attributes><text id="name">Rule</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id174500" pluginPredicateTypeIndex="0" eventType="touch"><attributes><index id="conditionType">0</index></attributes><predicate type="touch" conditionType="pressed"><attributes/></predicate></condition><condition id="id106546" pluginPredicateTypeIndex="0" eventType="touch"><attributes><index id="conditionType">0</index></attributes><predicate type="touch" conditionType="inside"><attributes/></predicate></condition></conditions><behaviors><behavior id="id329262" class="PlaySoundAction" enabled="true"><attributes><text id="name">Play Sound</text><text id="bundleName">PlaySound.behavior</text><sound id="soundName">Coin2</sound><boolean id="loop">false</boolean><boolean id="runToCompletion">true</boolean><boolean id="positional">false</boolean><boolean id="dopplerShift">false</boolean><real id="volume">1</real><real id="pitch">1</real></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></actor><actor id="id320851" prototype="id279196"><attributes><point id="position"><real id="x">384</real><real id="y">949</real></point><size id="size"><real id="width">774</real><real id="height">154</real></size><image id="image">UI_Shipyard</image></attributes><aspects/><behaviors><behavior id="id558305" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Cam Y Offset</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">self.attributes.position.y</text><text id="RHS"><expression><reference keypath="self.attributes.position.y"/><string xml:space="preserve">+</string><reference keypath="game.attributes.id628667"/></expression></text></attributes></behavior><behavior enabled="true" id="id755160" class="RuleBehavior"><attributes><text id="name">Go back to Main Menu</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id129490" pluginPredicateTypeIndex="0" eventType="touch"><attributes><index id="conditionType">0</index></attributes><predicate type="touch" conditionType="pressed"><attributes/></predicate></condition></conditions><behaviors><behavior id="id929030" class="ConstrainAttributeBehavior" enabled="true"><attributes><text id="name">Constrain Attribute</text><text id="bundleName">ConstrainAttribute.behavior</text><text id="targetAttribute">game.attributes.id539126</text><text id="RHS">100</text></attributes></behavior><behavior id="id459791" class="ChangeSceneAction" enabled="true"><attributes><text id="name">Change Scene</text><text id="bundleName">ChangeScene.behavior</text><text id="sceneKey">id659294</text><boolean id="enableAdvertisement">false</boolean><index id="index">1</index></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></actor><actor id="id401152" prototype="id699823"><attributes><text id="name">Fuel Card Button</text><point id="position"><real id="x">384</real><real id="y">500</real></point><size id="size"><real id="width">512</real><real id="height">150</real></size><image id="image">Fuel-Card</image></attributes><aspects/><behaviors><behavior id="id657603" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Cam Y Offset</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">self.attributes.position.y</text><text id="RHS"><expression><reference keypath="self.attributes.position.y"/><string xml:space="preserve">+</string><reference keypath="game.attributes.id628667"/></expression></text></attributes></behavior><behavior id="id419868" class="CompoundBehavior" enabled="true"><attributes><text id="name">New Code for Purchase</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id244292" class="CompoundBehavior" enabled="true"><attributes><text id="name">Load state of Ads Disabled attribute</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id518352" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First we need to load the saved state of the attribute we are going to use to save the state of the IAP. We need a game attribute (or table, if there are multiple IAPs) to save the state so we don’t need to depend on an internet connection to fill the PurchaseTable. If we don’t use a game attribute and the user doesn’t have an internet connection, there is no way to know if they have purchased the IAP or not. We store this using the “game.Item Purchased” attribute. 🔚</text></attributes></behavior><behavior id="id549614" class="LoadAttributeAction" enabled="true"><attributes><text id="name">Load state of CoinDoubler Purchased</text><text id="bundleName">LoadAtribute.behavior</text><text id="targetAttribute">game.attributes.id509879</text><text id="key">item2</text></attributes></behavior></behaviors></behavior><behavior id="id621415" class="CompoundBehavior" enabled="true"><attributes><text id="name">When the user presses the Buy Now button</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id320980" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When the user presses the Buy Now button, we have to check a number of attributes to see if the button is currently pressable. We first check if the IAP has already been bought, by ensuring the “game.Item Purchased” attribute is false. If it’s true, this button is disabled and we can reject any press. We also need to check if either a buy or restore is already in progress, and we do this by ensuring the “game.Buying” and “game.Restoring” attributes are false. 🔚</text></attributes></behavior><behavior enabled="true" id="id348092" class="RuleBehavior"><attributes><text id="name">Touch is pressed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id693781" pluginPredicateTypeIndex="0" eventType="touch"><attributes><index id="conditionType">0</index></attributes><predicate type="touch" conditionType="pressed"><attributes/></predicate></condition><condition id="id342190" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id788841" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id759606" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition></conditions><behaviors><behavior id="id551000" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the user has pressed the button, we need to provide some feedback. We do this by changing the button’s image to one telling the user to wait. This reassures the user that their press of the button has had some action. If we don’t change the image, it is likely to be a few seconds before they get Apple’s login or confirm purchase popups. 🔚</text></attributes></behavior><behavior id="id524592" class="PlaySoundAction" enabled="true"><attributes><text id="name">Play Sound</text><text id="bundleName">PlaySound.behavior</text><sound id="soundName">Coin2</sound><boolean id="loop">false</boolean><boolean id="runToCompletion">true</boolean><boolean id="positional">false</boolean><boolean id="dopplerShift">false</boolean><real id="volume">1</real><real id="pitch">1</real></attributes></behavior><behavior id="id238990" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Please-Wait</image></attributes></behavior><behavior id="id184789" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">The restore button also needs to know that the user pressed the Buy button. You could possibly rely on the 5th column of the PurchaseTable to notify the Restore button - this will soon be changed from “unpurchased” to “pending”. However, using that method relies on the table being filled with a Request Purchase Data behaviour, and we’re wanting to avoid triggering that until the user presses a button, so we need to rely on a game (or scene) attribute instead. We set that to true here.

Additionally, since we’re not calling the Request Purchase Data behaviour until the button is pressed, we need an attribute to trigger the actual purchase once the table is filled. 🔚</text></attributes></behavior><behavior id="id302384" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">true</text></attributes></behavior><behavior id="id597511" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Now we need to actually call the Request Purchase Data behaviour, and fill the PurchaseTable. First though we need to check that it hasn’t already been successfully filled. When you use a Request Purchase Data behaviour, it will fill the callback attribute you define with a 1 if it has succeeded, or a -1 if it has failed. If the callback attribute is not 1, the table has either not been attempted to be filled or has failed to fill, and we can trigger the Request Purchase Data behaviour.

The “Callback” attribute needs to be a game attribute so that the Restore button can also have access to the state of the table. Again we could use the contents of the 5th column of the PurchaseTable, but since we have to use an attribute to use the behaviour we might as well put it to full use. 🔚</text></attributes></behavior><behavior enabled="true" id="id599813" class="RuleBehavior"><attributes><text id="name">Rule</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id615225" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">!=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id758829" class="IAPRequestPurchaseDataAction" enabled="true"><attributes><text id="name">In App Purchase - Request Purchase Data</text><text id="bundleName">IAPRequestPurchaseData.behavior</text><text id="startIndex">1</text><text id="endIndex">-1</text><text id="callbackAttribute">game.attributes.id552612</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id225603" class="CompoundBehavior" enabled="true"><attributes><text id="name">Table filled - Success</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id783967" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Once the PurchaseTable has been successfully filled, GameSalad will change the “game.Callback” attribute to 1. As soon as this happens, we can get on with the actual Buying. 🔚</text></attributes></behavior><behavior enabled="true" id="id743979" class="RuleBehavior"><attributes><text id="name">Table filled - Success</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id108879" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id130495" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We only need to trigger the Buy behaviour if the player has pressed the Buy button. We are only ever going to allow a Buy to take place when the PurchaseTable has been filled, so we need to have that as a condition. We could actually combine these two rules into one rule with two conditions, but for this Tutorial Template it’s a clearer sequence of events if we separate them out.

If the PurchaseTable has been filled and the user has pressed the Buy button, triggering the “game.Buying” attribute, we make the actual purchase attempt. 🔚</text></attributes></behavior><behavior enabled="true" id="id575188" class="RuleBehavior"><attributes><text id="name">Buy the item</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id445512" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id735202" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Here we send the actual purchase request. 🔚</text></attributes></behavior><behavior id="id157932" class="IAPBuyItemAction" enabled="true"><attributes><text id="name">In App Purchase - Buy Item</text><text id="bundleName">IAPBuyItem.behavior</text><text id="itemIdentifier">fuel_Card</text></attributes></behavior><behavior id="id819230" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">This Change Table Value is not needed in any actual game is only included to make testing a little easier. In a real game, the moment the Purchase behaviour is triggered, GameSalad will change the 5th column of the PurchaseTable to “pending”. This happens automatically in a properly made ad hoc build, but doesn’t happen in Creator, Preview, or some types of ad hoc. Including this Change Table Value just saves us from having to press the “Pending” button that’s included in this Tutorial Template for illustrative and testing purposes.

Be sure to remove this (or not include it in the first place) if you use this method for IAP in your own game. 🔚</text></attributes></behavior><behavior class="ChangeTableValueAction" enabled="true"><attributes><text id="name">Change Table Value</text><text id="bundleName">ChangeTableValue.behavior</text><text id="tableID"></text><text id="tableExpression"><expression><reference keypath="game.attributes.id395449"/></expression></text><text id="rowNumber">2</text><array id="assignments"><tablecolumnassignment id="id429860"><text id="column">5</text><text id="rhsvalue">pending</text></tablecolumnassignment></array></attributes></behavior><behavior id="id209131" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When “game.Callback” is 1, and “game.Buying” is true, we can safely expect the cell in the 5th column of the PurchaseTable to say “pending”, as outlined above. This means that if both these conditions are valid and this cell says “unpurchased”, we know that purchase has failed - either because a connection could not be established, or more likely because the user pressed “Cancel”. In either case, we need to record that a purchase is no longer being attempted by setting “game.Buying” to false.

GameSalad does not guarantee order of execution of its behaviours, though. It is extremely unlikely but *possible* that this rule would be evaluated before the Purchase behaviour has been triggered and the cell changed to “pending”. You may want to put this rule in a short timer to ensure that the Purchase behaviour has time to trigger. I haven’t done so here, though. Worst case scenario is that the purchase is cancelled prematurely and the user has to trigger it again. 🔚</text></attributes></behavior><behavior enabled="true" id="id591025" class="RuleBehavior"><attributes><text id="name">Buying Failed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id754018" eventType="mouse position"><attributes><index id="conditionType">3</index></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS">unpurchased</text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><string xml:space="preserve">tableCellValue(</string><reference keypath="game.attributes.id395449"/><string xml:space="preserve">,1,5)</string></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id561446" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the purchase failed, for whatever reason, we may want to indicate this to the user by changing the Buy button’s image to reflect this failure. This is entirely optional, and if you do choose to do so you may want to revert the image back to the normal image after a set period of time, perhaps 3 seconds. We do this in a rule at the end. 🔚</text></attributes></behavior><behavior id="id143559" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Buy-Failed</image></attributes></behavior><behavior id="id837577" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">false</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id622027" class="CompoundBehavior" enabled="true"><attributes><text id="name">Table filled - Failure</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id157341" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If the PurchaseTable cannot be filled - for whatever reason - GameSalad will return a value of -1 using the “game.Callback” attribute. If this happens, we need to record that the purchase attempt has failed and keep trying to fill the PurchaseTable at set intervals. Until the table is successfully filled, both the Buy and Restore buttons will display an image that indicates this failure to connect to Apple’s servers to fill the table.

The user can either wait 10 seconds (or whatever interval you decide) for another attempt to be made, or can force another attempt by pressing either the Buy or Restore button. 🔚</text></attributes></behavior><behavior enabled="true" id="id358404" class="RuleBehavior"><attributes><text id="name">Table filled - Failure</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id536321" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">-1</string></expression></real></attributes></predicate></condition></conditions><behaviors><behavior id="id916928" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">The PurchaseTable couldn’t be filled, so there was a problem with the connection. We change the Buy button’s image to reflect this. 🔚</text></attributes></behavior><behavior id="id269110" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Can't-Connect</image></attributes></behavior><behavior id="id775072" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Without being able to talk to Apple, there’s no point trying to make a purchase, so we set “game.Buying” back to false, cancelling the purchase attempt. 🔚</text></attributes></behavior><behavior id="id733304" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">false</text></attributes></behavior><behavior id="id928110" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We might as well keep trying to fill the PurchaseTable, so every 10 seconds we’ll try again, until the table is filled. You can use any interval, but 10s seemed about right. 🔚</text></attributes></behavior><behavior id="id293551" class="TimerBehavior" enabled="true"><attributes><text id="name">Timer</text><text id="bundleName">Timer.behavior</text><index id="timerType">0</index><real id="interval">10</real><boolean id="runToCompletion">false</boolean></attributes><behaviors><behavior id="id322984" class="IAPRequestPurchaseDataAction" enabled="true"><attributes><text id="name">In App Purchase - Request Purchase Data</text><text id="bundleName">IAPRequestPurchaseData.behavior</text><text id="startIndex">1</text><text id="endIndex">-1</text><text id="callbackAttribute">game.attributes.id552612</text></attributes></behavior></behaviors></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id611988" class="CompoundBehavior" enabled="true"><attributes><text id="name">The IAP is successfully bought</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id250198" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">When the 5th column of the PurchaseTable changes to “purchased”, we need to register this in several ways. It indicates a successful purchase and so we need to change and save the “game.Item Purchased” attribute, as well as note that we are no longer buying an item. Finally, we change the button image.

This rule also works to trigger the change when a Restore is successfully completed, as the same table cell will change. 🔚</text></attributes></behavior><behavior enabled="true" id="id927834" class="RuleBehavior"><attributes><text id="name">Buying Succeeded</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id754018" eventType="mouse position"><attributes><index id="conditionType">3</index></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS">purchased</text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><string xml:space="preserve">tableCellValue(</string><reference keypath="game.attributes.id395449"/><string xml:space="preserve">,1,5)</string></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id325626" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First, we change the “game.Buying” attribute. As already mentioned, we need this attribute to indicate to other actors (in this case the Restore button) that a Buy is in progress. Since the Buy is now being completed, we note this by setting the “game.Buying” attribute to false.

Some of these things will only need to be triggered if the user is Buying, rather than Restoring, so we can put them in a rule to avoid processing them if it’s a Restore that’s triggered the change to the PurchaseTable. We find this out by checking the “game.Buying” attribute. We could actually handle all of the logic for completing a Restore in this actor too, and avoid a bit of duplication, but it seemed easier to have each button do its own thing for the sake of clarity in this Tutorial Template. 🔚</text></attributes></behavior><behavior enabled="true" id="id684125" class="RuleBehavior"><attributes><text id="name">When the user is Buying, not Restoring</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id871998" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id563257" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">First, we change the “game.Buying” attribute. As already mentioned, we need this attribute to indicate to other actors (in this case the Restore button) that a Buy is in progress. Since the Buy is now being completed, we note this by setting the “game.Buying” attribute to false. 🔚</text></attributes></behavior><behavior id="id503654" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS"><expression><string xml:space="preserve">true</string></expression></text></attributes></behavior><behavior id="id276824" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We’re storing the state of the purchase in the “game.Item Purchased” boolean attribute. If we don’t use this attribute, the game has no way of knowing if this item has been purchased when the user has no internet connection (and so the PurchaseTable is empty). As an alternative, we can save the PurchaseTable each time it is changed, but that seems to be a risky method that could lead to incorrect information. Using an attribute to store this information is cleaner and involves less processing. Here we set this attribute to “true” to record that the purchase has been successfully made. We then save it so its state will be remembered next time the game is launched. 🔚</text></attributes></behavior><behavior id="id117799" class="SaveAttributeAction" enabled="true"><attributes><text id="name">Save Attribute</text><text id="bundleName">SaveAttribute.behavior</text><text id="targetAttribute">game.attributes.id509879</text><text id="key"><expression><string xml:space="preserve">item2</string></expression></text></attributes></behavior><behavior id="id303045" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change Attribute</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">game.attributes.id632610</text><text id="RHS">true</text></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id193890" class="CompoundBehavior" enabled="true"><attributes><text id="name">When the IAP has been purchased and the game attribute changed</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id658795" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">We need to be checking for when the IAP Item has been purchased, and that change has been saved to our “game.Item Purchased” attribute. It may be that the user just completed a purchase and this attribute was changed in the rule above, or it may be that they purchased it in a previous session and the attribute has just been loaded by the game. Either way, we need to set the image for the Buy button to “Buy-Disabled”. 🔚</text></attributes></behavior><behavior enabled="true" id="id321137" class="RuleBehavior"><attributes><text id="name">When the IAP has been purchased and the game attribute changed</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id989636" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id899748" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since the purchase has been completed, either in a previous session or this one, we change the Buy button’s image to show this. In this example we’re just using a greyed-out version of the Buy image, but you could just as easily use any visual indication that this item has been purchased and is no longer available to buy. 🔚</text></attributes></behavior><behavior id="id487277" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Fuel-Card-Purchased</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id421477" class="CompoundBehavior" enabled="true"><attributes><text id="name">When Restoring Item</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id459708" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If the player presses the Restore button, we need to show that this action is in progress by changing the image of the Buy button too. We do that here. Just as we used a “game.Buying” attribute to indicate when a Buy is in progress, we use the “game.Restoring” attribute to show when a Restore is in progress. 🔚</text></attributes></behavior><behavior enabled="true" id="id425551" class="RuleBehavior"><attributes><text id="name">When Restoring Item</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id223388" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">1</index></attributes></predicate></condition></conditions><behaviors><behavior id="id771687" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">Since a Restore has been requested but not yet completed, we need to change the Buy button’s image to our “Please wait” image. As soon as the Restore is completed, we’ll either change the image back to our normal Buy button image, which happens below in the “Re-enable button when usable” rule, or replace it with the disabled image using the “The IAP is successfully bought” rule above. 🔚</text></attributes></behavior><behavior id="id880111" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Please-Wait</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id469880" class="CompoundBehavior" enabled="true"><attributes><text id="name">Re-enable button when usable</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id134816" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If we have no reason to change the Buy button’s image, we have to set it back to it’s default state. We need to check a whole bunch of things, though, to know that this should happen:

1. We have to check that we’re not currently Buying the item (if we were, “self.Image” would be set to “Buy-Wait”)
2. We have to check that we’re not currently Restoring the item (again, if we are “self.Image” would be set to “Buy-Wait”)
3. We have to check that the PurchaseTable has been successfully filled (again, “Buy-Wait” if not)
4. We have to check that the item hasn’t already been purchased (if it has been, “Buy-Disabled” will be displayed)
5. Finally, we don’t want to override the “Buy-Failed” image if that’s being displayed, so we have to check that it isn’t (if it is, we keep displaying “Buy-Failed”) - you can safely remove this condition if you aren’t using a failed image for the Buy button 🔚</text></attributes></behavior><behavior enabled="true" id="id724016" class="RuleBehavior"><attributes><text id="name">Re-enable button when usable</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition id="id223388" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id632610</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id468381" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id282712</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id387005" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id552612</text></attributes><predicate type="number"><attributes><text id="operator">=</text><real id="RHS"><expression><string xml:space="preserve">1</string></expression></real></attributes></predicate></condition><condition id="id989636" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">game.attributes.id148026</text></attributes><predicate type="boolean"><attributes><index id="RHS">0</index></attributes></predicate></condition><condition id="id190670" pluginPredicateTypeIndex="0" eventType="mouse position"><attributes><index id="conditionType">1</index><text id="subjectAttribute">self.attributes.image</text></attributes><predicate type="string"><attributes><text id="operator">isNot</text><text id="RHS"><expression><string xml:space="preserve">Can't-Connect</string></expression></text></attributes></predicate></condition></conditions><behaviors><behavior id="id154131" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Fuel-Card</image></attributes></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior><behavior id="id388021" class="CompoundBehavior" enabled="true"><attributes><text id="name">Reset button image after a failure</text><text id="bundleName">Group.behavior</text></attributes><behaviors><behavior id="id195156" class="NoteBehavior" enabled="true"><attributes><text id="name">Note</text><text id="bundleName">Note.behavior</text><text id="note">If you are choosing to display a “Buy-Failed” image, you may wish to restore the default image after a few seconds. There’s no specific need to - it may be that you prefer to leave the failed message there until the user attempts the purchase again. But if you do want to restore the default image, we just need to use a timer that changes the image after the desired interval. The only condition we need to place on it is that the “Buy-Failed” image is currently being displayed. 🔚</text></attributes></behavior><behavior enabled="true" id="id997261" class="RuleBehavior"><attributes><text id="name">Reset button image after a failure</text><text id="bundleName">Rule.behavior</text><real id="compoundConditionKind">0</real></attributes><conditions><condition pluginPredicateTypeIndex="0" id="id389874" eventType="mouse position"><attributes><index id="conditionType">3</index><text id="subjectAttribute">self.attributes.image</text></attributes><predicate type="string"><attributes><text id="operator">is</text><text id="RHS"><expression><string xml:space="preserve">Can't-Connect</string></expression></text></attributes></predicate><subjectPredicate type="string"><attributes><text id="operator">contains</text><text id="RHS"><expression><reference keypath="self.attributes.image"/></expression></text></attributes></subjectPredicate></condition></conditions><behaviors><behavior id="id886658" class="TimerBehavior" enabled="true"><attributes><text id="name">Timer</text><text id="bundleName">Timer.behavior</text><index id="timerType">1</index><real id="interval">3</real><boolean id="runToCompletion">false</boolean></attributes><behaviors><behavior id="id927015" class="ChangeImageAction" enabled="true"><attributes><text id="name">Change Image</text><text id="bundleName">ChangeImage.behavior</text><image id="image">Fuel-Card</image></attributes></behavior></behaviors></behavior></behaviors><elseBehaviors/></behavior></behaviors></behavior></behaviors></behavior></behaviors></actor><actor id="id545529" prototype="id452726"><attributes><point id="position"><real id="x">384</real><real id="y">300</real></point><size id="size"><real id="width">512</real><real id="height">150</real></size></attributes><aspects/></actor><actor id="id957664" prototype="id698508"><attributes><point id="position"><real id="x">-6</real><real id="y">-20</real></point></attributes><aspects/><behaviors><behavior id="id470552" class="ChangeAttributeAction" enabled="true"><attributes><text id="name">Change CamSize</text><text id="bundleName">ChangeAttribute.behavior</text><text id="targetAttribute">scene.attributes.camera.size.height</text><text id="RHS"><expression><reference keypath="game.attributes.id623313"/></expression></text></attributes></behavior></behaviors></actor></actors><attributes><text id="name">Lander Select</text><boolean id="scrollable">true</boolean></attributes></layer></layers><attributes><text id="name">Store</text><real id="time">0</real><size id="size"><real id="width">960</real><real id="height">1024</real></size><boolean id="wrapX">false</boolean><boolean id="wrapY">false</boolean><point id="gravity"><real id="x">0</real><real id="y">0</real></point><color id="color"><real id="red">0</real><real id="green">0</real><real id="blue">0</real><real id="alpha">1</real></color><rect id="camera"><point id="origin"><real id="x">0</real><real id="y">0</real></point><size id="size"><real id="width">768</real><real id="height">1024</real></size><size id="trackingArea"><real id="width">688</real><real id="height">944</real></size><real id="rotation">0</real></rect><attributes id="autorotate"><boolean id="landscapeLeft">false</boolean><boolean id="portrait">true</boolean><boolean id="landscapeRight">false</boolean><boolean id="portraitUpsideDown">false</boolean></attributes></attributes></scene>
